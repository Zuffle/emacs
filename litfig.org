#+PROPERTY: header-args :tangle ~/.config/emacs/init.el :mkdirp yes
* Literate Emacs init
This is my literate init file.

* Startup Performance

#+begin_src emacs-lisp
(defun efs/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                     (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)

(setq gc-cons-threshold (* 50 1000 1000))

(setq straight-check-for-modifications '(watch-files find-when-checking))
#+end_src

* Priority initializations
These are items that are prerequisite for other parts of my init so they will be loaded up first

** Straight.el
Straight setup is necessary near the beginning for *customization* purposes
*** Install

#+begin_src emacs-lisp

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq use-package-verbose t)
(setq use-package-minimum-reported-time 0)
#+end_src

early-init.el for straight
#+begin_src emacs-lisp :tangle ~/.config/emacs/early-init.el
(setq package-enable-at-startup nil)	; from straight.el to avoid
                                        ; pacakge.el loading packages
                                        ; prior to init.el

#+end_src

*** Configuration

#+begin_src emacs-lisp
(use-package straight
  :custom
  (straight-use-package-by-default t)
  )
#+end_src

** General.el
I am using general.el for key bindings and notably for ~general-setq~ for defcustom variable setting.

General.el is also useful for ~use-package~ declarations to specify keybindings, but I don't use it.

*** Install
#+begin_src emacs-lisp

(use-package general
  :config
  (general-evil-setup t)
  (defalias 'gsetq #'setq)
  )

#+end_src

* EMACS
This is for stuff that is native to emacs but might not fall under other categories
*************** TODO make defconsts for lists

TODO make defconsts for lists of things (ie the list of mode to exclude from line numbers
example below
*************** END


[[./emacs-general-defconst-example.png]]

** Install
#+begin_src emacs-lisp

(general-setq inhibit-startup-message t)

(general-setq source-directory "c:/Program Files/Emacs/emacs-27.2")

(general-setq
 safe-local-variable-values
 '((eval add-hook 'after-save-hook
	 (lambda nil
	   (if
	       (y-or-n-p "Tangle?")
	       (org-babel-tangle)))
	 nil t)))
#+end_src

** Functions
Some functions the most of which I likely found online
This also includes hook-functions I think


#+begin_src emacs-lisp

(defun bookmark-to-abbrevs ()
  "Create abbrevs based on `bookmark-alist'."
  (dolist (bookmark bookmark-alist)
    (let* ((name (car bookmark))
	   (file (bookmark-get-filename name)))
      (define-abbrev global-abbrev-table name file))))

(defun my-move-key (keymap-from keymap-to key)
  "Moves key binding from one keymap to another, deleting from the old location. "
  (define-key keymap-to key (lookup-key keymap-from key))
  (define-key keymap-from key nil))

(defun disable-line-numbers-mode ()
  "A function to add to mode hooks to prevent line numbers"
  (display-line-numbers-mode 0))

;;  Disable line numbers for modes in list
(dolist (mode '(
		org-mode-hook
		term-mode-hook
		shell-mode-hook
		eshell-mode-hook
		treemacs-mode-hook
		))
  (add-hook mode 'disable-line-numbers-mode))

;; (defun dw/switch-project-action ()
;;  "Switch to a workspace with the project name and start `magit-status'."
;;  ;; TODO: Switch to EXWM workspace 1?
;;  (persp-switch (projectile-project-name))
;;  (magit-status))

(defun efs/org-mode-setup ()
  (org-indent-mode)
  ;; (variable-pitch-mode 1)
  (auto-fill-mode 0)
  (visual-line-mode 1)
  (general-setq evil-auto-indent nil)
  )


#+end_src

**** Spacemacs functions
These are functions I am stealing from Spacemacs

#+begin_src emacs-lisp

(defun spacemacs/alternate-buffer (&optional window)
  "Switch back and forth between current and last buffer in the
  current window.
  If `spacemacs-layouts-restrict-spc-tab' is `t' then this only switches between
  the current layouts buffers."
  (interactive)
  (cl-destructuring-bind (buf start pos)
      (if (bound-and-true-p spacemacs-layouts-restrict-spc-tab)
	  (let ((buffer-list (persp-buffer-list))
		(my-buffer (window-buffer window)))
	    ;; find buffer of the same persp in window
	    (seq-find (lambda (it) ;; predicate
			(and (not (eq (car it) my-buffer))
			     (member (car it) buffer-list)))
		      (window-prev-buffers)
		      ;; default if found none
		      (list nil nil nil)))
	(or (cl-find (window-buffer window) (window-prev-buffers)
		     :key #'car :test-not #'eq)
	    (list (other-buffer) nil nil)))
    (if (not buf)
	(message "Last buffer not found.")
      (set-window-buffer-start-and-point window buf start pos))))

;; restart-emacs

(defun spacemacs/restart-emacs (&optional args)
  "Restart emacs."
  (interactive)
  (setq spacemacs-really-kill-emacs t)
  (restart-emacs args))

(defun spacemacs/restart-emacs-resume-layouts (&optional args)
  "Restart emacs and resume layouts."
  (interactive)
  (spacemacs/restart-emacs (cons "--resume-layouts" args)))

(defun spacemacs/restart-emacs-debug-init (&optional args)
  "Restart emacs and enable debug-init."
  (interactive)
  (spacemacs/restart-emacs (cons "--debug-init" args)))

(defun spacemacs/restart-emacs-timed-requires (&optional args)
  "Restart emacs and time loads / requires."
  (interactive)
  (spacemacs/restart-emacs (cons "--timed-requires" args)))

(defun spacemacs/restart-emacs-adv-timers (&optional args)
  "Restart emacs and time loads / requires and spacemacs configuration."
  (interactive)
  (spacemacs/restart-emacs (cons "--adv-timers" args)))

(defun spacemacs/restart-stock-emacs-with-packages (packages &optional args)
  "Restart emacs without the spacemacs configuration, enable
debug-init and load the given list of packages."
  (interactive
   (progn
     (unless package--initialized
       (package-initialize t))
     (let ((packages (append (mapcar 'car package-alist)
                             (mapcar 'car package-archive-contents)
                             (mapcar 'car package--builtins))))
       (setq packages (mapcar 'symbol-name packages))
       (let ((val (completing-read-multiple "Packages to load (comma separated): "
                                            packages nil t)))
         `(,val)))))
  (let ((load-packages-string (mapconcat (lambda (pkg) (format "(use-package %s)" pkg))
                                         packages " ")))
    (spacemacs/restart-emacs-debug-init
     (append (list "-q" "--execute"
                   (concat "(progn (package-initialize) "
                           "(require 'use-package)"
                           load-packages-string ")"))
             args))))

(defun spacemacs/switch-to-scratch-buffer (&optional arg)
  "Switch to the `*scratch*' buffer, creating it first if needed.
if prefix argument ARG is given, switch to it in an other, possibly new window."
  (interactive "P")
  (let ((exists (get-buffer "*scratch*")))
    (if arg
        (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (switch-to-buffer (get-buffer-create "*scratch*")))
    (when (not exists)
      (add-hook 'kill-buffer-hook
                #'spacemacs//confirm-kill-buffer
                nil t)
      (when (and (not (eq major-mode dotspacemacs-scratch-mode))
                 (fboundp dotspacemacs-scratch-mode))
        (funcall dotspacemacs-scratch-mode)
        (run-hooks 'spacemacs-scratch-mode-hook)))))

#+end_src

* UI
** General
#+begin_src emacs-lisp

(scroll-bar-mode -1)			;disable visible scroll bar
(tool-bar-mode -1)			; disable tool bar
(tooltip-mode -1)			; disable tooltips
(set-fringe-mode -1)			;give breathing room ?
(menu-bar-mode -1)			; disable menu bar

(general-setq display-line-numbers-type 'relative)
(global-display-line-numbers-mode t)
(general-setq visible-bell t)			; change audio bells to visual

#+end_src

** Font
TODO fonts and corss machine when they aren't available on every machine?
Some fonts I like:
+ Mint preinstalled:
+ Serif
  + Gurajada Regular (nice numbers too)
  + Likhan Normal
  + NTR (/best roman + cool nums)
  + P052 Roman
  + Rekhaz
  + Sarai Regular
  + Suravaram WINNER for now
+ Sans
  + Laksaman (fun)
  + Khmer OS Regular
  + Potti Sreeramulu
  + TenaliRamakrishna Regular
  + Umpush
  + Ubuntu
  + 


#+begin_src emacs-lisp

  (set-face-attribute 'default nil
		      :font "Fira Mono"
		      )

  (set-face-attribute 'fixed-pitch nil
		      :font "Fira Mono"
		      )

  ;; (set-face-attribute 'variable-pitch nil
		      ;; :font "Suravaram"
		      ;; )


#+end_src


** Theme
Still deciding on a theme
#+begin_src emacs-lisp

(load-theme 'tsdh-dark)

#+end_src

** Gotta fix Unicode stuff here
#+begin_src emacs-lisp

;; UTF-8 support

(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)    
(general-setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

* Terminal
Making terminal emulators useful in emacs, or maybe more convenient

** term-mode
term-mode is a built-in terminal emulator in Emacs. Because it is written in Emacs Lisp, you can start using it immediately with very little configuration. If you are on Linux or macOS, term-mode is a great choice to get started because it supports fairly complex terminal applications (htop, vim, etc) and works pretty reliably. However, because it is written in Emacs Lisp, it can be slower than other options like vterm. The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is line-mode versus char-mode. line-mode enables you to use normal Emacs keybindings while moving around in the terminal buffer while char-mode sends most of your keypresses to the underlying terminal. While using term-mode, you will want to be in char-mode for any terminal applications that have their own keybindings. If you’re just in your usual shell, line-mode is sufficient and feels more integrated with Emacs.

With evil-collection installed, you will automatically switch to char-mode when you enter Evil’s insert mode (press i). You will automatically be switched back to line-mode when you enter Evil’s normal mode (press ESC).

Run a terminal with M-x term!

Useful key bindings:

    C-c C-p / C-c C-n - go back and forward in the buffer’s prompts (also [[ and ]] with evil-mode)
    C-c C-k - Enter char-mode
    C-c C-j - Return to line-mode
    If you have evil-collection installed, term-mode will enter char mode when you use Evil’s Insert mode

#+begin_src emacs-lisp
(use-package term
  :commands (term)
  :config
  (gsetq explicit-shell-file-name "bash") ;; Change this to zsh, etc
  ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

  ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
  (gsetq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))
#+end_src

Better term-mode colors

The eterm-256color package enhances the output of term-mode to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to. Keep in mind that this package requires ncurses to be installed on your machine so that it has access to the tic program. Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp
(use-package eterm-256color
  :ghook
  ('term-mode  #'eterm-256color-mode)
)

#+end_src

** vterm
vterm is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications. This enables it to be much faster than term-mode and to also provide a more complete terminal emulation experience.

Make sure that you have the necessary dependencies installed before trying to use vterm because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp

(use-package vterm
  :commands vterm
  :config
  ;; (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000))

#+end_src

** Eshell
Eshell is Emacs’ own shell implementation written in Emacs Lisp. It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (ls, rm, mv, grep, etc). It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing vim to find-file). Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don’t work as well. However, many of these limitations can be dealt with by good configuration and installing external packages, so don’t let that discourage you from trying it!

Useful key bindings:

    C-c C-p / C-c C-n - go back and forward in the buffer’s prompts (also [[ and ]] with evil-mode)
    M-p / M-n - go back and forward in the input history
    C-c C-u - delete the current input string backwards up to the cursor
    counsel-esh-history - A searchable history of commands typed into Eshell

    #+begin_src emacs-lisp

    (defun efs/configure-eshell ()
      ;; Save command history when commands are entered
      (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

      ;; Truncate buffer for performance
      (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

      ;; Bind some useful keys for evil-mode
      (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
      (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
      (evil-normalize-keymaps)

      (setq eshell-history-size         10000
            eshell-buffer-maximum-lines 10000
            eshell-hist-ignoredups t
            eshell-scroll-to-bottom-on-input t))

    (use-package eshell-git-prompt
      :after eshell)

    (use-package eshell
      :ghook
      ('(eshell-first-time-mode)  #'efs/configure-eshell)
      :config

      (with-eval-after-load 'esh-opt
        (gsetq eshell-destroy-buffer-when-process-dies t)
        (gsetq eshell-visual-commands '("htop" "zsh" "vim")))

      (eshell-git-prompt-use-theme 'powerline))

    #+end_src

* File Management
** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings

**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!
 
**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** Configuration
#+begin_src emacs-lisp

(use-package dired
  :ensure nil
  :straight nil
  :commands (dired dired-jump)
  ;; :bind (("C-x C-j" . dired-jump))
  ;; :custom ((dired-listing-switches "-agho --group-directories-first"))
  :config
  (general-def 'normal dired-mode-map
    "h" 'dired-single-up-directory
    "l" 'dired-single-buffer)
)

(use-package dired-single
  :after dired)

(use-package all-the-icons
  :defer t)

(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package dired-open
  :after dired
  :config
  ;; Doesn't work as expected!
  ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
  (setq dired-open-extensions '(("png" . "feh")
				("mkv" . "mpv"))))

(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :config
  (general-def 'normal dired-mode-map
    "H" 'dired-hide-dotfiles-mode))

#+end_src

* Packages
** Ivy
*** Install
#+begin_src emacs-lisp
(use-package ivy
  :general
  (
   "C-s" 'swiper
   "M-x" 'counsel-M-x
   "C-x b" 'counsel-ibuffer
   "C-x C-f" 'counsel-find-file
   "C-M-l" 'counsel-imenu
   )
  (:keymaps 'minibuffer-local-map
	    "C-r" '(counsel-minibuffer-history)
	    )
  (:keymaps 'ivy-minibuffer-map
	    "C-l" 'ivy-alt-done
	    "C-j" 'ivy-next-line
	    "C-k" 'ivy-previous-line
	    )
  (:keymaps 'ivy-switch-buffer-map
	    "C-k" 'ivy-previous-line
	    "C-l" 'ivy-done
	    "C-d" 'ivy-switch-buffer-kill
	    )
  (:keymaps 'ivy-reverse-i-search-map
	    "C-k" 'ivy-previous-line
	    "C-d" 'ivy-reverse-i-search-kill
	    )
  :config
  (ivy-mode 1)
  )
#+end_src

*** Ivy rich
Don't super remember what this is for
**** Install
#+begin_src emacs-lisp
(use-package ivy-rich
  :after ivy
  :config
  (ivy-rich-mode 1)
  )

#+end_src

*** Ivy hydra
Ivy and hydra integration
**** Install
#+begin_src emacs-lisp
(use-package ivy-hydra
  :after ivy
  )

#+end_src
*** Counsel
Counsel is actually like wrapping emacs commands with Ivy enhancements

**** Install
#+begin_src emacs-lisp
(use-package counsel
  :after ivy
  :config
  (counsel-mode 1))
#+end_src

*** Counsel-projectile
Counsel and projectile integration

**** Install
#+begin_src emacs-lisp
(use-package counsel-projectile
  :after (projectile)
  :bind (("C-M-p" . counsel-projectile-find-file))
  :config
  (counsel-projectile-mode)
  )

#+end_src

** Doom-themes
#+begin_src emacs-lisp
(use-package doom-themes
  ;; :init (load-theme 'doom-wilmersdorf t)
)

#+end_src

** Evil
Extensible vim emulation layer! 

*** Hooks
It seems like we need this add-to-list function for evil-emacs-state-modes to be in a hook otherwise it might not fire correctly
#+begin_src emacs-lisp
;;  evil emacs state mode hook
(defun jsp/emacs-state-hook ()
    (dolist (mode '(
		    eshell-mode
		    howm-menu-mode
		    Info-mode
		    ))
      (dolist (state `(
		       ,evil-emacs-state-modes
		       ,evil-insert-state-modes
		       ,evil-normal-state-modes
		       ,evil-motion-state-modes
		       ))
	(delete mode state))
      (add-to-list 'evil-emacs-state-modes mode))
)

#+end_src

*** Install
#+begin_src emacs-lisp
(use-package evil
  ;; :defer t
  :demand t
  :init
  (general-setq evil-want-integration t)
  (general-setq evil-want-keybinding nil)
  (general-setq evil-want-C-u-scroll t)
  (general-setq evil-want-C-w-in-emacs-state t)
  (general-setq evil-want-Y-yank-to-eol t)
  (general-setq evil-want-C-i-jump nil)
  ;; (general-setq evil-default-state 'emacs)
  :hook
  (evil-mode . jsp/emacs-state-hook)
  (howm-menu . evil-initialize)

  :config
  (evil-mode  1)
  (general-setq evil-undo-system 'undo-tree)
  ;; (my-move-key evil-motion-state-map evil-normal-state-map (kbd "RET"))
  ;; (my-move-key evil-motion-state-map evil-normal-state-map " ") 
  (general-unbind 'motion
    "SPC"
    )
  
  )

#+end_src

*** Evil collection
A set of package to further integrate evil into emacs

**** Hooks
#+begin_src emacs-lisp
(defun jsp/remove-from-evil-collection-list ()
      (dolist (mode `(
		      info
		       ))
	(delete mode evil-collection-mode-list))
      )
#+end_src
**** Install
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    ;; :hook
    ;; (evil-collection jsp/remove-from-evil-collection-list)
    :config
    (jsp/remove-from-evil-collection-list)
    (evil-collection-init)
    )

#+end_src

*** Evil escape
can use a key sequence to get back into normal mode

**** Install
#+begin_src emacs-lisp
(use-package evil-escape
  :defer t
  :commands (evil-escape-pre-command-hook)
  :init (general-add-hook 'pre-command-hook 'evil-escape-pre-command-hook)
  :config
  (evil-escape-mode 1)
  :custom
  (evil-escape-excluded-states '(emacs))
  )

#+end_src

*** Evil surround
add "s" bindings to normal mode to "surround" which is a command that
takes a character as argument and will surround the selection with it

**** Install

#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1)
  )

#+end_src

** Esup
*** Install
#+begin_src emacs-lisp
(use-package esup
  :commands esup
  :config
  ;; (gsetq esup-user-init-file "/home/jsp/.config/emacs/init.el") 
  (gsetq esup-depth 0)
)
#+end_src

** Helpful
Package that revamps Emacs builtin help commands
*** Install
#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-command] . helpful-command)
  ([remap describe-key] . helpful-key)
  )

#+end_src

** Howm
A note taking mode for emacs designed around quick note taking and creating a personal wiki

Howm is not really stubborn, it just activates howm-menu-mode in an unanticipated way.
That way is by evalling (howm-menu-mode) itself during (howm-menu-refresh) which is called when typing the C-c ,-, keybinding

*** Install
#+begin_src emacs-lisp

(use-package howm
  :commands (howm-menu)
  ;; :init
  ;; :hook
  ;; (howm-menu . evil-emacs-state)
  ;; ;; :config
  ;; (turn-off-evil-mode)
  )

#+end_src

** Hydra
Another keybinding like package but more for temporary/quick actions

*** Install
#+begin_src emacs-lisp
(use-package hydra
  )

#+end_src

** lsp
Language server protocol to add language specific syntax and other IDE like features

*** Install
#+begin_src emacs-lisp

(use-package lsp-mode
  :init
  (gsetq lsp-keymap-prefix "SPC l")
  :ghook
  ;; modes that use lsp or lsp-deferred in my case
  ('(c++-mode-hook c-mode-hook) #'lsp-deferred)

  :gfhook
  #'lsp-enable-which-key-integration
  :commands (lsp lsp-deferred)
  )

#+end_src

*** lsp-pyright for python
Not sure if I have to install this with pip

**** Install
#+begin_src emacs-lisp
;; function to add to python-mode-hook instead of lambda
(defun my-lsp-pyright-hook ()
  (require 'lsp-pyright)
  (lsp-deferred))

(use-package lsp-pyright
  :ghook
  ('python-mode-hook  #'my-lsp-pyright-hook)
  )
#+end_src

*** lsp-ui
Documentation [[https://emacs-lsp.github.io/lsp-ui/#intro][lsp-ui]]
Adds some ui features with lsp-mode. Nothing seems to show up by default and lsp-ui-doc
has some problems with the way it shows the doc window

**** Install
#+begin_src emacs-lisp
(use-package lsp-ui :commands lsp-ui-mode)

#+end_src

*** lsp-treemacs
Some cool treemacs style "code trees" to display the structure of your code.
This packages needs svg support I think so I added in a check for SVG support.

**** Install
#+begin_src emacs-lisp
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list
    :config
    (unless  (image-type-available-p 'svg)
      (lwarn 'lsp-treemacs 'warning "SVG support not available in this build of Emacs.\nRebuild with SVG support for lsp-treemacs")
    )
  )

#+end_src

*** lsp-ivy
**** Install
#+begin_src emacs-lisp
(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
#+end_src

*** company-mode

**** Install
#+begin_src emacs-lisp
(use-package company
  ;; :after lsp-mode
  :hook (lsp-mode . company-mode)
  ;; :bind (:map company-active-map
  ;;        ("<tab>" . company-complete-selection))
  ;;       (:map lsp-mode-map
  ;;        ("<tab>" . company-indent-or-complete-common))
  :general
  (:keymaps 'company-active-map
            "<tab>" 'company-complete-selection)
  (:keymaps 'lsp-mode-map
        "TAB" 'company-indent-or-complete-common)
  :config
  (gsetq company-minimum-prefix-length 1
	 company-idle-delay 0.0)
  ;; (general-def
  ;;   :keymaps 'company-mode-map
  ;;   "TAB" 'company-complete-selection
  ;;   )
  )

(use-package company-box
  :hook (company-mode . company-box-mode))

#+end_src

** Magit
Git integration into emacs. Very handy

*** Install
#+begin_src emacs-lisp
(use-package magit
  :commands magit-status
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  )

#+end_src

** Org
You know what Org mode is

*** Install
#+begin_src emacs-lisp
(use-package org
  :defer t
  :custom
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  :gfhook
  #'efs/org-mode-setup
  :config
  ;; customize vars with gsetq
  (require 'org-inlinetask)

  ;; shortcut to enter structure templates org-tempo
  (gsetq org-modules (append org-modules '(org-tempo)))
  (dolist (template '(
		      ("el" . "src emacs-lisp")
		      ("py" . "src python")
		      ("c" . "src C")
		      ("cpp" . "src C++")
		      ("center" . "center")
		      ))
    (when (assoc (car template) org-structure-template-alist)
       (assoc-delete-all (car template) org-structure-template-alist))
     (add-to-list 'org-structure-template-alist template t))
  ;; efs 
  (general-setq org-ellipsis " ▾")

  ;; efs ep6 //
  ;; set which files should be used to populate agenda with tasks
  (general-setq org-agenda-files
	'("~/orgfiles/tasks.org"
	  "~/orgfiles/bdays.org")
	)

  (general-setq org-agenda-start-with-log-mode t)
  (general-setq org-log-done 'time)
  (general-setq org-log-into-drawer t)
  (general-setq org-todo-keywords
	'((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
	  (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
  (general-setq org-refile-targets
	'(("Archive.org" :maxlevel . 1)
	  ("Tasks.org" :maxlevel . 1)))

  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)

  (general-setq org-tag-alist
	'((:startgroup)
					; Put mutually exclusive tags here
	  (:endgroup)
	  ("@errand" . ?E)
	  ("@home" . ?H)
	  ("@work" . ?W)
	  ("agenda" . ?a)
	  ("planning" . ?p)
	  ("publish" . ?P)
	  ("batch" . ?b)
	  ("note" . ?n)
	  ("idea" . ?i)))


  (general-setq org-capture-templates
	`(("t" "Tasks / Projects")
	  ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
	   "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

	  ("j" "Journal Entries")
	  ("jj" "Journal" entry
	   (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
	   "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
	   ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
	   :clock-in :clock-resume
	   :empty-lines 1)
	  ("jm" "Meeting" entry
	   (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
	   "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
	   :clock-in :clock-resume
	   :empty-lines 1)

	  ("w" "Workflows")
	  ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
	   "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

	  ("m" "Metrics Capture")
	  ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
	   "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))
  ;; // efs ep6
  ;; set background color for src blocks
  (require 'color)
  (set-face-attribute 'org-block nil
		      :foreground
		      (color-darken-name
		       (face-attribute 'default :foreground) 15)
		      :background
		      (color-darken-name
		       (face-attribute 'default :background) 3))
		      
;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    (set-face-attribute (car face) nil :weight 'normal :height (* 1.4 (cdr face))))

 ;; Make sure org-indent face is available
(require 'org-indent)

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

;; Get rid of the background on column views
(set-face-attribute 'org-column nil :background nil)
(set-face-attribute 'org-column-title nil :background nil)

;; TODO: Others to consider
;; '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
;; '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
;; '(org-property-value ((t (:inherit fixed-pitch))) t)
;; '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
;; '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
;; '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
;; '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))

)  

#+end_src

*** Unused from EFS
#+begin_src emacs-lisp
;; Configure custom agenda views
;; a bit overkill for me rn
;; (general-setq org-agenda-custom-commands
;;       '(("d" "Dashboard"
;; 	 ((agenda "" ((org-deadline-warning-days 7)))
;; 	  (todo "NEXT"
;; 		((org-agenda-overriding-header "Next Tasks")))
;; 	  (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

;; 	("n" "Next Tasks"
;; 	 ((todo "NEXT"
;; 		((org-agenda-overriding-header "Next Tasks")))))

;; 	("W" "Work Tasks" tags-todo "+work-email")

;; 	;; Low-effort next actions
;; 	("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
;; 	 ((org-agenda-overriding-header "Low Effort Tasks")
;; 	  (org-agenda-max-todos 20)
;; 	  (org-agenda-files org-agenda-files)))

;; 	("w" "Workflow Status"
;; 	 ((todo "WAIT"
;; 		((org-agenda-overriding-header "Waiting on External")
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "REVIEW"
;; 		((org-agenda-overriding-header "In Review")
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "PLAN"
;; 		((org-agenda-overriding-header "In Planning")
;; 		 (org-agenda-todo-list-sublevels nil)
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "BACKLOG"
;; 		((org-agenda-overriding-header "Project Backlog")
;; 		 (org-agenda-todo-list-sublevels nil)
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "READY"
;; 		((org-agenda-overriding-header "Ready for Work")
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "ACTIVE"
;; 		((org-agenda-overriding-header "Active Projects")
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "COMPLETED"
;; 		((org-agenda-overriding-header "Completed Projects")
;; 		 (org-agenda-files org-agenda-files)))
;; 	  (todo "CANC"
;; 		((org-agenda-overriding-header "Cancelled Projects")
;; 		 (org-agenda-files org-agenda-files)))))))
#+end_src

*** Org Superstar
Customize org mode bullet. Successor to org-bullets.el

**** Install
#+begin_src emacs-lisp
(use-package org-superstar
  :after org
  :hook (org-mode . org-superstar-mode)
  :custom
  (org-superstar-headline-bullets-list #'("◉" "○" "✸" "✿"))
  ;; (org-superstar-leading-bullet ".")
  )

#+end_src

*** Org contrib
Compilation of third party contributions to org mode.
I got this for org-eldoc.el!

**** Install
#+begin_src emacs-lisp
(use-package org-contrib
  :after org
  :config
  (org-eldoc-load)
  )

#+end_src

** Projectile
A package that allows for easy actionables within organized project workspaces

*** Install
#+begin_src emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :custom (projectile-completion-system 'ivy)
  ;; :bind-keymap
  ;; ("C-c p" . projectile-command-map)
  :general
  ("C-c p" 'projectile-command-map)
  :init
  (when (file-directory-p "~/projects/coding")
    (general-setq projectile-project-search-path '("~/projects/coding")))
  (general-setq projectile-switch-project-action #'dw/projectile-dired)
  )

#+end_src

** Rainbow delimiter
This package will color matching delimiters for distinguishing things like parens levels

*** Install
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Restart Emacs
A useful package to restart emacs from within emacs (Spacemacs uses this)

#+begin_src emacs-lisp
(use-package restart-emacs
  :defer 3
  )
#+end_src
** Smex
This is used with Counsel for M-x to have recently used commands at the top of the list

*** Install
#+begin_src emacs-lisp
(use-package smex)

#+end_src

** Spaceline
A package that copies Spacemacs' unique modeline
*** Install
#+begin_src emacs-lisp 
(use-package spaceline
  :config
  (spaceline-emacs-theme)
  )
#+end_src

** undo-tree
Quick way to enable undoing with Evil mode.

*** Install
#+begin_src emacs-lisp
(use-package undo-tree
  :defer 3
  :config
  (global-undo-tree-mode 1)
  (defvar undo-dir (concat user-emacs-directory "undo/"))
  (general-setq undo-tree-history-directory-alist `(("." . ,undo-dir)))
  (general-setq undo-tree-auto-save-history nil)
  )

#+end_src

*** TODO Look into other ways to enable undoing with Evil mode
** which-key
Awesome package that shows keybinding/keychord completions in the minibuffer

*** Install
#+begin_src emacs-lisp
(use-package which-key
  :defer 0
  :diminish which-key-mode
  :config
  (which-key-mode)
  (general-setq which-key-idle-delay 0.3)
  ;; (general-setq which-key-separator " -> ")
  )

#+end_src
* Key bindings
** Hydra Macros
My hydra macros

#+begin_src emacs-lisp
;; text scale hydra
(defhydra hydra-text-scale (:timeout 4)
  "scale text"
  ("j" text-scale-decrease "out")
  ("k" text-scale-increase "in")
  ("0" (text-scale-set 0))
  ("q" nil "quit")
  )
  
;; buffer hydra
(defhydra hydra-buffer-nav (:timeout 4)
  "navigate buffers"
)

#+end_src
** Leader Key Keybindings
I wanted to use SPC as my leader key, like Spacemacs which introduced me to Emacs. To accomplish this I am using General.el's [[help:general-create-definer][general-create-definer]], using the :states and :keymaps. Override keymap is necessary because before using it, I noticed "SPC" in Dired was not activating my leader key, but dired-next-line

#+begin_src emacs-lisp
(general-create-definer jep/leader-keys
  :states '(normal insert emacs visual)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
  "SPC" '(counsel-M-x :wk "M-x")
  )

#+end_src
*** Prefix key setup
I use multiple prefixes to branch into different key bindings chords

#+begin_src emacs-lisp
(jep/leader-keys
  "TAB" '(spacemacs/alternate-buffer :wk "last buffer")

  ;; prefix key setup
  "f" '(:ignore t :wk "files")
  "t" '(:ignore t :wk "toggles")
  "a" '(:ignore t :wk "applications")
  "w" '(:ignore t :wk "window")
  "h" '(:ignore t :wk "help")
  "b" '(:ignore t :wk "buffers")
  ";" '(:ignore t :wk "comment")
  "p" '(projectile-command-map :wk "projectile")
  "g" '(:ignore t :which-key "git")
  "l" '(lsp-command-keymap :wk "lsp (low prio)")
  "q" '(:ignore t :wk "quit")

  )

#+end_src

*** Buffers

#+begin_src emacs-lisp
(jep/leader-keys
  :infix "b"
  "k" '(kill-current-buffer :wk)
  "b" '(counsel-switch-buffer :wk)
  "c" '(clean-buffer-list :wk)
  "s" '(spacemacs/switch-to-scratch-buffer :wk "scratch buffer")
  )

#+end_src

*** Comments

#+begin_src emacs-lisp
(jep/leader-keys
  :infix ";"
  ";" '(comment-line :wk)		
  )					

#+end_src

*** Files

#+begin_src emacs-lisp
;; FILES
(jep/leader-keys
  :infix "f"
  "f" '(counsel-find-file :wk)
  "s" '(save-buffer :wk)
  "r" '(counsel-recentf :wk)
  )

#+end_src

*** Git

#+begin_src emacs-lisp
;; GIT
(jep/leader-keys
  :infix "g"
  "s"  'magit-status
  "d"  'magit-diff-unstaged
  "c"  'magit-branch-or-checkout
  "l"   '(:ignore t :which-key "log")
  "lc" 'magit-log-current
  "lf" 'magit-log-buffer-file
  "b"  'magit-branch
  "P"  'magit-push-current
  "p"  'magit-pull-branch
  "f"  'magit-fetch
  "F"  'magit-fetch-all
  "r"  'magit-rebase
  )

#+end_src

*** Help

#+begin_src emacs-lisp
;; HELP
(jep/leader-keys
  :infix "h"
  "d" '(:ignore t :wk "describe")
  "dv" '(describe-variable :wk)
  "df" '(describe-function :wk)
  "dk" '(describe-key :wk)
  "dg" '(general-describe-keybindings :wk)
  "dm" '(describe-mode :wk)
  )

#+end_src

*** Toggles

#+begin_src emacs-lisp
;; TOGGLES
(jep/leader-keys
  :infix "t"
  "t" '(counsel-load-theme :which-key)
  "s" '(hydra-text-scale/body :wk)
  )

#+end_src

*** Search

#+begin_src emacs-lisp
;; SEARCH
(jep/leader-keys
  :infix "s"
  "s" '(swiper :wk)
  )

#+end_src

*** Windows

#+begin_src emacs-lisp
;; WINDOW
(jep/leader-keys
  :infix "w"
  "d" '(:wk)
  )

#+end_src

*** Project
This may not be necessary with ~projectile-command-map~ bound to SPC-p
#+begin_src emacs-lisp
;; PROJECT
;; (jep/leader-keys
;;   :infix "p"
;;   "f"  'counsel-projectile-find-file
;;   "s"  'counsel-projectile-switch-project
;;   "F"  'counsel-projectile-rg
;;   ;; "pF"  'consult-ripgrep
;;   "p"  'counsel-projectile
;;   "c"  'projectile-compile-project
;;   "d"  'projectile-dired)

#+end_src

*** Quit

#+begin_src emacs-lisp
;; QUIT
(jep/leader-keys
  :infix "q"
  "q" '(save-buffers-kill-terminal :wk)
  ;; "r" '(spacemacs/restart-emacs-resume-layouts :wk)
  "r" '(spacemacs/restart-emacs :wk)
  )

#+end_src

* End
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1000 1000))
#+end_src

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda nil (if (y-or-n-p "Tangle?") (org-babel-tangle))) nil t)
# End:
